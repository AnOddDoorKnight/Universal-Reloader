version "4.0"

class HDUniversalReloader : HDWeapon
{
	// [Ace] Now I'm starting to understand why Matt used an array for WeaponStatus. It allows transferring data between spare weapons. Neat.
	enum RProperty
	{
		RProperty_RoundsToMake,
		RProperty_SelectedRecipe
	}

	enum FAction
	{
		FAction_None,
		FAction_Assemble,
		FAction_Disassemble
	}

	override void BeginPlay()
	{
		Super.BeginPlay();
		
		HDRel_Recipe r;
		if (r = HDRel_Recipe.TryCreate("HDPistolAmmo",		"HDRel_RawLead",	2, 1.00,	"HDRel_RawPlastic",	1, 0.75,	"HDRel_RawPowder",	1, 0.50, 1.50)) Recipes.Push(r); // Vanilla HD
		if (r = HDRel_Recipe.TryCreate("HDRevolverAmmo",	"HDRel_RawLead",	2, 1.00,	"HDRel_RawBrass",	1, 0.70,	"HDRel_RawPowder",	2, 1.25, 1.00)) Recipes.Push(r); // Vanilla HD
		if (r = HDRel_Recipe.TryCreate("HDShellAmmo",		"HDRel_RawLead",	4, 3.00,	"HDRel_RawPlastic",	2, 1.00,	"HDRel_RawPowder",	1, 0.50, 1.00)) Recipes.Push(r); // Vanilla HD
		if (r = HDRel_Recipe.TryCreate("FourMilAmmo",		"HDRel_RawLead",	0, 1.00,	null,				0, 0.00,	"HDRel_RawPowder",	0, 1.00, 5.00)) Recipes.Push(r); // Vanilla HD
		if (r = HDRel_Recipe.TryCreate("SevenMilAmmo",		"HDRel_RawLead",	2, 1.50,	"HDRel_RawBrass",	2, 1.75,	"HDRel_RawPowder",	4, 2.50, 1.00)) Recipes.Push(r); // Vanilla HD
		if (r = HDRel_Recipe.TryCreate("SevenMilBrass",		null,				0, 0.00,	"HDRel_RawBrass",	0, 1.75,	null,				0, 0.00, 1.00)) Recipes.Push(r); // Vanilla HD
		if (r = HDRel_Recipe.TryCreate("HDOtisLightAmmo",	"HDRel_RawLead",	3, 2.25,	"HDRel_RawBrass",	2, 1.25,	"HDRel_RawPowder",	2, 1.00, 0.75)) Recipes.Push(r); // Otis-5, peppergrinder.pk3
		if (r = HDRel_Recipe.TryCreate("HDOtisHeavyAmmo",	"HDRel_RawLead",	4, 3.00,	"HDRel_RawBrass",	2, 1.25,	"HDRel_RawPowder",	2, 1.00, 0.75)) Recipes.Push(r); // Otis-5, peppergrinder.pk3
		if (r = HDRel_Recipe.TryCreate("HDNDMLoose",		"HDRel_RawLead",	4, 2.75,	"HDRel_RawBrass",	1, 0.75,	"HDRel_RawPowder",	2, 1.00, 1.00)) Recipes.Push(r); // Guillotine, peppergrinder.pk3
		if (r = HDRel_Recipe.TryCreate("HD50OMGAmmo",		"HDRel_RawLead",	5, 3.80,	"HDRel_RawBrass",	4, 3.00,	"HDRel_RawPowder",	6, 4.00, 0.50)) Recipes.Push(r); // ZM69
		if (r = HDRel_Recipe.TryCreate("HD50AM_Ammo",		"HDRel_RawLead",	3, 2.25,	"HDRel_RawBrass",	2, 1.25,	"HDRel_RawPowder",	2, 1.00, 0.75)) Recipes.Push(r); // .50 AM, potetobloke's guns

		WeaponStatus[RProperty_RoundsToMake] = 7;
	}

	// [Ace] Booooooooooooooring. Never gonna touch these.
	override string, double GetPickupSprite() { return "URLDA0", 1.0; }
	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Assemble rounds\n"
		..WEPHELP_UNLOAD.."+"..WEPHELP_FIRE.." Disassemble rounds/casings\n"
		..WEPHELP_FIREMODE.."+"..WEPHELP_FIRE.."/"..WEPHELP_ALTFIRE.."  Cycle ammo\n"
		..WEPHELP_ZOOM.."+"..WEPHELP_UPDOWN.."  Adjust factory amount";
	}
	override double GunMass() { return 0; }
	override double WeaponBulk() { return 50 * Amount; }
	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner, bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override int GetSbarNum(int flags) { return GetRoundsToMake(); }

	protected clearscope HDRel_Recipe, int GetSelectedRecipe()
	{
		int Size = Recipes.Size();
		int SelIndex = WeaponStatus[RProperty_SelectedRecipe];
		if (Size > 0 && SelIndex < Size) // [Ace] Just in case someone magically manages to set this to an out-of-bounds index.
		{
			return Recipes[SelIndex];
		}

		return null;
	}

	protected clearscope int GetRoundsToMake()
	{
		return WeaponStatus[RProperty_RoundsToMake];
	}

	override void DropOneAmmo(int amt)
	{
		if (owner)
		{
			static const int ThrowAngles[] = { 0, 30, -30 };

			double OriginalAngle = owner.Angle;
			let SelRecipe = GetSelectedRecipe();

			for (int i = 0; i < MaterialCount; ++i)
			{
				if (owner.CheckInventory(SelRecipe.Materials[i], 1))
				{
					owner.Angle = OriginalAngle + ThrowAngles[i];
					owner.A_DropInventory(SelRecipe.Materials[i], random(5, 15));
				}
			}
			owner.Angle = OriginalAngle;
		}
	}

	// [Ace] This is where the good stuff begins.

	override void ActualPickup(actor other, bool silent)
	{
		Super.ActualPickup(other, silent);

		if (!owner)
		{
			return;
		}

		ChugTicker = 0;
		HDRel_Recipe SelRecipe = GetSelectedRecipe();
		switch (FactoryAction)
		{
			case FAction_Assemble:
				for (int i = 0; i < MaterialCount; ++i)
				{
					while (LoadedMats[i] > 0)
					{
						LoadedMats[i]--;
						if (owner.A_JumpIfInventory(SelRecipe.Materials[i], 0, "null"))
						{
							owner.A_SpawnItemEx(SelRecipe.Materials[i], 0, 0, owner.height - 16, 2, 0, 1);
						}
						else
						{
							HDF.Give(owner, SelRecipe.Materials[i], 1);
						}
					}
				}
				break;
			case FAction_Disassemble:
				while (LoadedRounds > 0)
				{
					LoadedRounds--;
					if (owner.A_JumpIfInventory(SelRecipe.AmmoClass, 0, "null"))
					{
						owner.A_SpawnItemEx(SelRecipe.AmmoClass, 0, 0, owner.height - 16, 2, 0, 1);
					}
					else
					{
						HDF.Give(owner, SelRecipe.AmmoClass, 1);
					}
				}
				break;
		}
		FactoryAction = FAction_None;
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		vector2 bob = hpl.hudbob * 0.3;
		int BaseYOffset = -182;
		
		sb.DrawImage("URLDA0", (0, BaseYOffset + 68) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER, alpha: 1.0, scale:(2, 2));
		let CurrRecipe = GetSelectedRecipe();
		if (CurrRecipe)
		{
			bool CanAssemble = CurrRecipe.CanBeAssembled();

			let AmmoClass = GetDefaultByType(CurrRecipe.AmmoClass);
			string AmmoIcon = TexMan.GetName(AmmoClass.Icon);
			string AmmoTag = AmmoClass.GetTag();

			double DrawAlpha = HasMaterials(CanAssemble ? FAction_Assemble : FAction_Disassemble, CurrRecipe) ? 1.0 : 0.6;
			sb.DrawImage(AmmoIcon, (0, BaseYOffset + 4) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER, alpha: 1.0, scale: (2.5, 2.5));

			string AmmoNumbers = CanAssemble ? GetMaxAssemblyAmount(CurrRecipe).." ("..sb.GetAmount(AmmoClass.GetClass())..")" : sb.FormatNumber(sb.GetAmount(AmmoClass.GetClass()), 1, 4);
			sb.DrawString(sb.pSmallFont, AmmoNumbers, (0, BaseYOffset + 22) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_WHITE, DrawAlpha);
			sb.DrawString(sb.pSmallFont, AmmoTag, (0, BaseYOffset + 32) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_DARKGRAY, DrawAlpha);
			if (!CanAssemble)
			{
				sb.DrawString(sb.pSmallFont, "Cannot be assembled", (0, BaseYOffset + 42) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_RED, DrawAlpha);
			}

			for (int i = 0; i < MaterialCount; ++i)
			{
				if (!CurrRecipe.Materials[i])
				{
					continue;
				}

				let CurrMat = GetDefaultByType(CurrRecipe.Materials[i]);
				sb.DrawImage(TexMan.GetName(CurrMat.Icon), (-80 + 80 * i, BaseYOffset + 96) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER, alpha: DrawAlpha, scale: (2.5, 2.5));
				
				string CostString = sb.FormatNumber(CurrRecipe.Costs[i], 1, 2);
				double ProductAmount = CurrRecipe.Products[i];
				string ProductString = String.Format(ProductAmount % 1.0 ~== 0 ? "%i" : "%.2F", ProductAmount);
				sb.DrawString(sb.pSmallFont, CanAssemble ? CostString.."/"..ProductString : ProductString, (-80 + 80 * i, BaseYOffset + 106) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_WHITE, DrawAlpha);
				
				sb.DrawString(sb.pSmallFont, "("..sb.GetAmount(CurrMat.GetClass())..")", (-80 + 80 * i, BaseYOffset + 116) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_WHITE, DrawAlpha);
				sb.DrawString(sb.pSmallFont, CurrMat.GetTag(), (-80 + 80 * i, BaseYOffset + 126) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_DARKGRAY, DrawAlpha, 80, 1);
			}
		}
		else
		{
			sb.DrawString(sb.pSmallFont, "No recipe selected.", (0, BaseYOffset + 96) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GOLD);
		}
	}

	protected clearscope int GetMaxAssemblyAmount(HDRel_Recipe recipe)
	{
		int MaxAssemblyAmount = 5000;

		for (int i = 0; i < MaterialCount; ++i)
		{
			int MaxAmount = owner.CountInv(Recipe.Materials[i]) / Recipe.Costs[i]; // [Ace] Possible division by zero. Should that happen, don't call the dang function if recipe can't be assembled!
			if (MaxAmount < MaxAssemblyAmount)
			{
				MaxAssemblyAmount = MaxAmount;
			}
		}

		return MaxAssemblyAmount;
	}

	protected clearscope bool HasMaterials(FAction fact, HDRel_Recipe recipe)
	{
		switch (fact)
		{
			case FAction_Assemble:
				for (int i = 0; i < MaterialCount; ++i)
				{
					if (owner.CountInv(recipe.Materials[i]) < recipe.Costs[i])
					{
						return false;
					}
				}
				break;
			case FAction_Disassemble:
				if (owner.CountInv(recipe.AmmoClass) <= 0)
				{
					return false;
				}
				break;
		}

		return true;
	}

	protected virtual int GetBoomChance(FAction fact, int rounds) const
	{
		switch (fact)
		{
			default: return 0;
			case FAction_Assemble: return 5 + int(round(rounds / 3.0));
			case FAction_Disassemble: return 5;
		}
	}

	protected virtual int GetChugSpeed(FAction fact, int rounds, double mult) const
	{
		int BaseSpeed;
		switch (fact)
		{
			default: return 1;
			case FAction_Assemble: BaseSpeed = 35 - rounds; break;
			case FAction_Disassemble: BaseSpeed = 5; break;
		}

		int ActualSpeed = int(BaseSpeed / mult);
		if (frandom[chugrand](0.01, 1.00) < mult % 1.0)
		{
			ActualSpeed++;
		}

		return max(1, ActualSpeed);
	}

	protected action void A_CheckCycle(int cycleDir)
	{
		int SelIndex = invoker.WeaponStatus[RProperty_SelectedRecipe];
		switch (cycleDir)
		{
			case 1:
				++SelIndex %= invoker.Recipes.Size();
				break;
			case -1:
				SelIndex = SelIndex == 0 ? invoker.Recipes.Size() - 1 : SelIndex - 1;
				break;
		}
		invoker.WeaponStatus[RProperty_SelectedRecipe] = SelIndex;
	}

	protected action void A_CheckFactory(FAction fact)
	{
		HDRel_Recipe SelRecipe = invoker.GetSelectedRecipe();
		if (!SelRecipe || fact == FAction_None || fact == FAction_Assemble && !SelRecipe.CanBeAssembled() || !invoker.HasMaterials(fact, SelRecipe)) // [Ace] Lack of parentheses for the OR is intentional. Don't "fix" it again, you dolt.
		{
			return;
		}

		invoker.FactoryAction = fact;
		switch (fact)
		{
			case FAction_Assemble:
				for (int i = 0; i < MaterialCount; ++i)
				{
					int Cost = SelRecipe.Costs[i];
					int MatInvAmount = CountInv(SelRecipe.Materials[i]);
					int AssemblyLoadAmount = min(MatInvAmount, Cost * invoker.GetRoundsToMake());
					if (AssemblyLoadAmount > 0)
					{
						invoker.LoadedMats[i] = AssemblyLoadAmount;
						A_TakeInventory(SelRecipe.Materials[i], AssemblyLoadAmount);
					}
				}
				break;
				
			case FAction_Disassemble:
				int AmmoInvAmount = CountInv(SelRecipe.AmmoClass);
				int DisassemblyLoadAmount = min(AmmoInvAmount, invoker.GetRoundsToMake());
				if (DisassemblyLoadAmount > 0)
				{
					invoker.LoadedRounds = DisassemblyLoadAmount;
					A_TakeInventory(SelRecipe.AmmoClass, DisassemblyLoadAmount);
				}
				break;
		}
		DropInventory(invoker);
	}

	const MaterialCount = 3;

	private int LoadedMats[MaterialCount];
	private int LoadedRounds;
	protected FAction FactoryAction;
	protected Array<HDRel_Recipe> Recipes; // [Ace] This is never checked for Size() > 0, but it's virtually impossible to abort unless Matt changes all the class names overnight.
	private int CurrIndex;
	private int ChugTicker;

	Default
	{
		+WEAPON.WIMPY_WEAPON
		+INVENTORY.INVBAR
		+HDWEAPON.FITSINBACKPACK
		Inventory.PickupSound "misc/w_pkup";
		Inventory.PickupMessage "Picked up a universal reloading device.";
		Scale 0.6;
		HDWeapon.RefId "url";
		Tag "Universal reloading device";
	}

	States
	{
		Spawn:
			URLD A -1 NoDelay A_JumpIf(invoker.FactoryAction > FAction_None, "Chug");
			Stop;
		Select0:
			TNT1 A 0 A_Raise(999);
			Wait;
		Deselect0:
			TNT1 A 0 A_Lower(999);
			Wait;
		Ready:
			TNT1 A 1
			{
				if (PressingZoom())
				{
					// [Ace] This code is copy-pasted from HD and I have no idea what all them bitshifts are supposed to do or why they're used in the first place.
					int InputAmount = player.cmd.pitch;
					if(InputAmount)
					{
						if(abs(InputAmount) < (1 << 7))
						{
							InputAmount = clamp(InputAmount, -1, 1);
						}
						else
						{
							InputAmount >>= 7;
						}
					}
					InputAmount += (justpressed(BT_ATTACK) ? 1 : justpressed(BT_ALTATTACK) ? -1 : 0);
					HijackMouse();
					invoker.WeaponStatus[RProperty_RoundsToMake] = clamp(invoker.GetRoundsToMake() + InputAmount, 1, 30);
				}
				else
				{
					A_WeaponReady(WRF_ALLOWUSER3);
				}
			}
			Goto ReadyEnd;
		Fire:
			TNT1 A 5
			{
				if (player.cmd.buttons & BT_USER2)
				{
					A_CheckCycle(1);
				}
				else
				{
					A_CheckFactory(player.cmd.buttons & BT_USER4 ? FAction_Disassemble : FAction_Assemble);
				}
			}
			Goto Ready;
		AltFire:
			TNT1 A 5
			{
				if (player.cmd.buttons & BT_USER2)
				{
					A_CheckCycle(-1);
				}
			}
			Goto Ready;
		User3:
			#### A 0 A_SelectWeapon("PickupManager");
			Goto Ready;
		Chug:
			#### A 0
			{
				A_StartSound("roundmaker/chug1", 8);
				A_StartSound("roundmaker/chug2", 9);
				vel.z += randompick(-1, 1);
				vel.xy += (frandom(-0.3, 0.3),frandom(-0.3, 0.3));

				if (invoker.ChugTicker++ >= invoker.GetChugSpeed(invoker.FactoryAction, invoker.GetRoundsToMake(), invoker.GetSelectedRecipe().SpeedMult))
				{
					invoker.ChugTicker = 0;
					return ResolveState("Blargh");
				}

				return ResolveState(null);
			}
			#### A 3;
			Loop;
		Blargh:
			#### A 10
			{
				HDRel_Recipe SelRecipe = invoker.GetSelectedRecipe();
				A_StartSound("roundmaker/pop", 10);
				switch (invoker.FactoryAction)
				{
					case FAction_Assemble:
						for (int i = 0; i < MaterialCount; ++i)
						{
							invoker.LoadedMats[i] -= SelRecipe.Costs[i];
						}
						if (random(1, 100) <= invoker.GetBoomChance(FAction_Assemble, invoker.GetRoundsToMake()))
						{
							A_SpawnItemEx("HDExplosion");
							A_Explode(32, 32);
						}
						else
						{
							A_SpawnItemEx(SelRecipe.AmmoClass, 0, 0, 0, 1, 0, 3, 0, SXF_NOCHECKPOSITION);
						}

						for (int i = 0; i < MaterialCount; ++i)
						{
							if (invoker.LoadedMats[i] < SelRecipe.Costs[i])
							{
								invoker.FactoryAction = FAction_None;
								return;
							}
						}
						break;

					case FAction_Disassemble:
						invoker.LoadedRounds--;
						if(random(1, 100) <= invoker.GetBoomChance(FAction_Disassemble, invoker.GetRoundsToMake()))
						{
							A_SpawnItemEx("HDExplosion");
							A_Explode(32, 32);
						}
						else
						{
							for (int i = 0; i < MaterialCount; ++i)
							{
								int ActualAmount = int(SelRecipe.Products[i]);
								if (frandom[prodrand](0.01, 1.00) < SelRecipe.Products[i] % 1.0)
								{
									ActualAmount++;
								}
								for (int j = 0; j < ActualAmount; ++j)
								{
									A_SpawnItemEx(SelRecipe.Materials[i], 0, 0, 0, 1, 0, 3, random(0, 359), SXF_NOCHECKPOSITION);
								}
							}

							if (invoker.LoadedRounds <= 0)
							{
								invoker.FactoryAction = FAction_None;
								return;
							}
						}
						break;
				}
				
			}
			#### A 0 A_Jump(256, "Spawn");
			Stop;
	}
}

class HDRel_CraftingMaterial : HDAmmo
{
	enum PType
	{
		PType_None,
		PType_Ball,
		PType_Pile
	}

	override void GetItemsThatUseThis()
	{
		ItemsThatUseThis.Push("HDUniversalReloader");
	}

	override string PickupMessage()
	{
		return Amount > 1 ? PileMessage : default.PickupMsg; 
	}

	override void SplitPickup()
	{
		if (PileType == PType_None)
		{
			return;
		}

		int SplitAmount = min(Amount, random(4, 26));
		while (Amount > SplitAmount)
		{
			int SubSplit = min(Amount, random(4, 26));
			Actor a = Spawn(GetClass(), pos);
			a.vel += vel + (frandom(-1, 1), frandom(-1, 1), frandom(-1, 1));
			Inventory(a).Amount = SubSplit;
			Amount -= SubSplit;
		}

		if (amount < 1)
		{
			Destroy();
			return;
		}

		switch (PileType)
		{
			case PType_Pile:
				scale.y = default.scale.y * max(1.0, Amount * 0.1);
				if (Amount > 1)
				{
					Frame = 1;
				}
				break;
			case PType_Ball:
				scale = default.scale * max(1.0, Amount * 0.1);
				break;
		}
	}


	PType PileType;
	property PileType: PileType;

	string PileMessage;
	property PileMessage: PileMessage;

	Default
	{
		+FORCEXYBILLBOARD
		+HDPICKUP.MULTIPICKUP
	}
}

// [Ace] Just in case I want to change things individually later down the line.
class HDRel_CasingMaterial : HDRel_CraftingMaterial { }
class HDRel_PowderMaterial : HDRel_CraftingMaterial { }
class HDRel_ProjectileMaterial : HDRel_CraftingMaterial { }

class HDRel_RawBrass : HDRel_CasingMaterial
{
	Default
	{
		Tag "Brass";
		Inventory.Icon "BRMTA0";
		Inventory.PickupMessage "Picked up some brass materials.";
		HDRel_CraftingMaterial.PileMessage "Picked up a ball of brass.";
		HDRel_CraftingMaterial.PileType PType_Ball;
		HDPickup.Bulk 0.20;
	}

	States
	{
		Spawn:
			BRMT A -1;
			Stop;
	}
}

class HDRel_RawPlastic : HDRel_CasingMaterial
{
	Default
	{
		Tag "Plastic";
		Inventory.Icon "PLTCA0";
		Inventory.PickupMessage "Picked up some plastic materials.";
		HDRel_CraftingMaterial.PileMessage "Picked up a pile of plastic.";
		HDRel_CraftingMaterial.PileType PType_None;
		HDPickup.Bulk 0.11;
		Scale 0.4;
	}

	States
	{
		Spawn:
			PLTC A -1;
			Stop;
	}
}

class HDRel_RawLead : HDRel_ProjectileMaterial 
{
	Default
	{
		Tag "Lead";
		Inventory.Icon "LEADA0";
		Inventory.PickupMessage "Picked up some lead materials.";
		HDRel_CraftingMaterial.PileMessage "Picked up a ball of lead.";
		HDRel_CraftingMaterial.PileType PType_Ball;
		HDPickup.Bulk 0.25;
		Scale 0.8;
	}

	States
	{
		Spawn:
			LEAD A -1;
			Stop;
	}
}

class HDRel_RawPowder : HDRel_PowderMaterial
{
	Default
	{
		Tag "Powder";
		Inventory.Icon "PWDRA0";
		Inventory.PickupMessage "Picked up some powder.";
		HDRel_CraftingMaterial.PileMessage "Picked up a pile of powder.";
		HDRel_CraftingMaterial.PileType PType_Pile;
		HDPickup.Bulk 0.08;
	}

	States
	{
		Spawn:
			PWDR A -1;
			Stop;
	}
}

// [Ace] This is used for both crafting and disassembly.
class HDRel_Recipe
{
	class<HDAmmo> AmmoClass;
	class<HDRel_CraftingMaterial> Materials[HDUniversalReloader.MaterialCount];
	int Costs[HDUniversalReloader.MaterialCount];
	double Products[HDUniversalReloader.MaterialCount];
	bool SpeedMult;

	static HDRel_Recipe TryCreate(string amcls, class<HDRel_ProjectileMaterial> projMat, int projCost, double projProd, class<HDRel_CasingMaterial> casingMat, int csgCost, double csgProd, class<HDRel_PowderMaterial> powderMat, int pwdCost, double pwdProd, double speed)
	{
		HDRel_Recipe Ret = new("HDRel_Recipe");
		
		Ret.AmmoClass = amcls;
		if (Ret.AmmoClass)
		{
			Ret.Materials[0] = projMat;
			Ret.Costs[0] = projCost;
			Ret.Products[0] = projProd;

			Ret.Materials[1] = casingMat;
			Ret.Costs[1] = csgCost;
			Ret.Products[1] = csgProd;

			Ret.Materials[2] = powderMat;
			Ret.Costs[2] = pwdCost;
			Ret.Products[2] = pwdProd;

			Ret.SpeedMult = speed;

			return Ret;
		}

		return null;
	}

	// [Ace] Can't assemble something that's missing a material.
	bool CanBeAssembled()
	{
		for (int i = 0; i < Materials.Size(); ++i)
		{
			if (!Materials[i])
			{
				return false;
			}
		}

		return true;
	}
}